"""
This program is mainly used to score the performance of various SInE paramters on the deepmath benchmark.
The evaluation is computed in terms of the coverage and jaccard score of the generated problems in regards
to the ground truth of the deepmath problems. We can also add clauses generated by the captioning model
with and without 'include_rare'. This helps us to isolate the effect of SInE and find the optimal parameters.

If we do not supply any SInE options, we compare the given directory to the ground truth. This can be useful
for evaluation the performance metrics of the problems computed by 'generate_problems.py'
"""

import argparse
import re
import sys
import numpy as np
from pathlib import Path
from multiprocessing import Pool
import socket
import os

from model import get_model_params
from evaluate import get_model
from generate_problems import (
    get_problems_from_path,
    load_and_process_problem,
    sine_process,
    extract_rare_axioms,
    compute_caption,
)
from evaluate import jaccard_score_np, coverage_score_np
from dataset import get_tokenizer
from dataset import load_photo_features
import config
from utils import get_sampler_parser


# Set the number of workers - only used in multiprocessing
NO_WORKERS = os.cpu_count() - 1

if socket.gethostname() == "kontor":
    DATASET_PATH = "/home/eholden/gnn-entailment-caption/nndata/"
else:
    DATASET_PATH = "/shareddata/home/holden/gnn-entailment-caption/nndata/"


RE_CLAUSE_FILE = b"file\('(\/|\w)*',(\w*)\)\)."
RE_POSITIVE_CLAUSE_NAME_PROBLEM = b"^\+ fof\((\w+), axiom"  # only positive axioms
RE_CLAUSE_NAME_PROBLEM = "^fof\((\w+), axiom"
# RE_CLAUSE_NAME_PROBLEM = "fof\((\w+), axiom"


def get_score_parser():

    #parser = argparse.ArgumentParser()
    parser = get_sampler_parser()

    parser.add_argument("--sine_sd", type=int, nargs="+", default=None)
    parser.add_argument("--sine_st", type=float, nargs="+", default=None)

    parser.add_argument(
        "--model_dir", default=None, help="Path to sequence model, used if including predictions"
    )
    parser.add_argument(
        "--include_rare_axioms", default=False, action="store_true", help="Include rare axioms"
    )
    parser.add_argument(
        "--feature_path",
        default=config.problem_features,
        help="Path to the problem embeddings used with the captioning model",
    )
    parser.add_argument(
        "--number_of_samples",
        type=int,
        default=None,
        help="Number of samples to use for computing the score (None for all)",
    )
    parser.add_argument(
        "--problem_format",
        default="deepmath",
        choices=["deepmath", "mptp"],
        help="The problem format of the benchmark",
    )

    parser.add_argument(
        "--problem_dir",
        default=DATASET_PATH,
        help="The directory of the problems processed (typically by SInE)",
    )

    return parser


def get_sine_clause_names(prob):
    res = re.findall(RE_CLAUSE_FILE, prob)
    # res = re.findall(RE_CLAUSE_NAME_PROBLEM, prob)
    res = [r[1] for r in res]
    return res


def get_positive_clause_names(prob):
    res = re.findall(RE_POSITIVE_CLAUSE_NAME_PROBLEM, prob, flags=re.MULTILINE)
    return res


def get_clause_names(prob):
    res = re.findall(RE_CLAUSE_NAME_PROBLEM, prob, flags=re.MULTILINE)
    return res


def sine_score_problem(prob_path, sine_st, sine_sd, selected_axioms, deepmath):

    # Load the clauses from the problem
    prob = load_and_process_problem(prob_path, deepmath=deepmath)

    # Clausify the problem - optionally with SInE
    prob_processed = sine_process(prob, sine_st=sine_st, sine_sd=sine_sd, prob_name=Path(prob_path).stem)
    del prob

    # Extract the clause names from the sine processed problem
    # Get processed clause names
    processed_names = get_sine_clause_names(prob_processed)

    # Get the ground truth of names
    with open(DATASET_PATH + Path(prob_path).stem, "rb") as f:  # Need to open the original dataset file
        prob_original = f.read()
    prob_names = get_positive_clause_names(prob_original)
    del prob_original

    if len(prob_names) == 0:
        print(f"ERROR: No clause names for problem {prob_path}", file=sys.stderr)

    # Add selected axioms to the set of sine names
    processed_names = set(processed_names).union(selected_axioms)

    # Compute the scores - no avg as it is single entry anyways
    jaccard = jaccard_score_np([prob_names], [processed_names], avg=False)[0]
    coverage = coverage_score_np([prob_names], [processed_names], avg=False)[0]

    # Return result
    return Path(prob_path).stem, {"jaccard": jaccard, "coverage": coverage}


def sine_score_set(problem_paths, sine_st, sine_sd, selected_axioms_dict, deepmath):

    # Iterate over each problem and compute their SiNe representation and their scores - include the set of selected axioms
    map_args = [
        (prob_path, sine_st, sine_sd, selected_axioms_dict.get(Path(prob_path).stem, set()), deepmath)
        for prob_path in problem_paths
    ]
    pool = Pool(NO_WORKERS)
    res = pool.starmap(sine_score_problem, map_args)
    pool.close()
    pool.join()

    # Set the socre dict
    scores = {prob: s for prob, s in res}

    avg_jaccard = np.average([v["jaccard"] for v in scores.values()])
    avg_coverage = np.average([v["coverage"] for v in scores.values()])

    return avg_jaccard, avg_coverage


def print_results_table(results, sine_st, sine_sd):

    # Function for printing table line
    def print_line():
        print("-" * (4 + (14 * len(sine_st))))

    # Pretty print our results
    print("(Jaccard , Coverage)")
    print("   |" + "|".join([f"    {st:>4}     " for st in sine_st]) + "|")
    print_line()
    for sd, res in zip(sine_sd, results):
        print(f" {sd} |" + "|".join([f" {r[0]:>5.2f} {r[1]:>5.2f} " for r in res]) + "|")
        print_line()


def get_rare_axioms(prob_path, tokenizer):
    prob = load_and_process_problem(prob_path)
    rare_axiom_clauses = extract_rare_axioms(tokenizer, prob)

    # Extract the clause names
    rare_axiom_names = get_clause_names("\n".join(rare_axiom_clauses))
    assert len(rare_axiom_names) == len(rare_axiom_clauses)

    # Convert to bytes
    rare_axiom_names = {ax.encode() for ax in rare_axiom_names}
    return Path(prob_path).stem, rare_axiom_names


def get_selected_axioms(model_dir, feature_path, problem_paths, include_rare_axioms, sampler, max_length, no_samples, sampler_temperature, sampler_top_k):

    # Initialise ctionary which stores the additional axioms for each problem
    selected_axioms_dict = {}

    # Get the tokenizer from the model params
    tokenizer, vocab_size = get_tokenizer(
        config.train_id_file,
        'axioms',
        config.proof_data,
        get_model_params(model_dir).axiom_vocab_size,
    )


    # Include rare axioms if set
    rare_axioms = {}
    if include_rare_axioms:
        print("Extracting rare axioms")
        map_args = [(prob_path, tokenizer) for prob_path in problem_paths]
        pool = Pool(NO_WORKERS)
        res = pool.starmap(get_rare_axioms, map_args)
        pool.close()
        pool.join()
        rare_axioms = {prob: s for prob, s in res}

    # Compute axioms with model if set
    sequence_axioms = {}
    if model_dir is not None:
        print("Predicting axioms")
        problem_features = load_photo_features(feature_path, [Path(p).stem for p in problem_paths])

        # Load the model
        model = get_model(model_dir, vocab_size)

        for prob_path in problem_paths:
            axiom_caption = compute_caption(tokenizer, model, problem_features[Path(prob_path).stem], sampler, max_length, no_samples, sampler_temperature, sampler_top_k)

            # Extract the clause names
            axiom_caption = get_clause_names("\n".join(axiom_caption))

            axiom_caption = [ax.encode() for ax in axiom_caption]  # Ensure axioms are bytes

            sequence_axioms[Path(prob_path).stem] = axiom_caption

    # Join the two dicts
    for prob_path in problem_paths:
        prob = Path(prob_path).stem
        selected_axioms_dict[prob] = rare_axioms.get(prob, set()).union(sequence_axioms.get(prob, set()))

    return selected_axioms_dict


def main():
    # Parse input arguments
    args = get_score_parser().parse_args()

    # Check that both SInE parameters are specified
    if (args.sine_sd is None and args.sine_st is not None) or (
        args.sine_sd is not None and args.sine_st is None
    ):
        raise ValueError("Both depth and treshold for SInE must be set.")

    # Get path to all problems
    problem_paths = get_problems_from_path(args.problem_dir, limit=args.number_of_samples)
    assert len(problem_paths) > 0, "No problems found at the given problem directory"
    print(f"Comparing ground in : {DATASET_PATH}")
    print("with problems in    :", args.problem_dir)

    # Deduce the problem format
    deepmath = args.problem_format == "deepmath"

    # We compute the sequence problems first as it is unaffected by the sine parameters.
    # Load tokenizer if needed
    if args.model_dir is not None or args.include_rare_axioms:
        # Add axioms from the captioning model / include_rare
        print("WARNING deperecated - need to update functions")
        selected_axioms_dict = get_selected_axioms(
            args.model_dir, args.feature_path, problem_paths, args.include_rare_axioms,
            args.sampler, args.max_length, args.no_samples[0], args.sampler_temperature, args.sampler_top_k
        )
    else:
        # Set the empty dictionary if not including any extra axioms
        selected_axioms_dict = {}

    # If SInE is set, we run through all cogifurations, otherwise loop over all and print a nice table
    if args.sine_sd is None and args.sine_st is None:
        res = sine_score_set(problem_paths, None, None, selected_axioms_dict, deepmath)
        print(f"Avg Jaccard:  {res[0]:.2f}")
        print(f"Avg Coverage: {res[1]:.2f}")

    else:
        # Initialise results matrix
        results = [[-1] * len(args.sine_st)] * len(args.sine_sd)

        # Compute results
        for nt, st in enumerate(args.sine_st):
            for nd, sd in enumerate(args.sine_sd):
                print(f"sd:{sd} st{st}")
                res = sine_score_set(problem_paths, st, sd, selected_axioms_dict, deepmath)
                results[nd][nt] = res

        print_results_table(results, args.sine_st, args.sine_sd)


if __name__ == "__main__":
    main()
